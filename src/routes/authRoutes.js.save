import express from 'express';
import bcrypt from 'bcrypt';
import prisma from '../prisma.js';
import { signAccess, signRefresh, verifyRefresh } from '../utils/jwt.js';

const router = express.Router();
const COOKIE_NAME = process.env.REFRESH_COOKIE_NAME || 'curalink_refresh';
const COOKIE_OPTIONS = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax',
  maxAge: (() => {
    const days = parseInt(process.env.REFRESH_TOKEN_DAYS || '30', 10);
    return days * 24 * 60 * 60 * 1000;
  })()
};

// Helper: find or create user by email
async function findOrCreateUser({ name, email, phone, role = 'patient', auth_uid = null }) {
  let user = await prisma.users.findUnique({ where: { email } });
  if (!user) {
    user = await prisma.users.create({
      data: { name: name || email.split('@')[0], email, phone: phone || null, role, auth_uid }
    });
  }
  return user;
}

// POST /api/auth/register
router.post('/register', async (req, res, next) => {
  try {
    const { name, email, phone, password, role } = req.body;
    if (!name || !email || !password) return res.status(400).json({ error: 'Missing fields' });

    const existing = await prisma.users.findUnique({ where: { email }});
    if (existing) return res.status(400).json({ error: 'Email already exists' });

    // create user row
    const user = await prisma.users.create({
      data: { name, email, phone: phone || null, role: role || 'patient' }
    });

    // store password hash in credentials table (raw SQL to avoid modelling)
    const hash = await bcrypt.hash(password, 10);
    await prisma.$executeRaw`INSERT INTO credentials(user_id, password_hash) VALUES (${user.id}::uuid, ${hash})`;

    const access = signAccess({ userId: user.id, role: user.role });
    const refresh = signRefresh({ userId: user.id, role: user.role });

    res.cookie(COOKIE_NAME, refresh, COOKIE_OPTIONS);
    res.json({ access, user });
  } catch (err) {
    next(err);
  }
});

// POST /api/auth/login
router.post('/login', async (req, res, next) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'Missing fields' });

    const user = await prisma.users.findUnique({ where: { email }});
    if (!user) return res.status(400).json({ error: 'Invalid credentials' });

    const rows = await prisma.$queryRaw`SELECT password_hash FROM credentials WHERE user_id = ${user.id} LIMIT 1`;
    const hashed = rows?.[0]?.password_hash;
    if (!hashed) return res.status(400).json({ error: 'No local credentials found. Please use Google login or register.' });

    const ok = await bcrypt.compare(password, hashed);
    if (!ok) return res.status(400).json({ error: 'Invalid credentials' });

    const access = signAccess({ userId: user.id, role: user.role });
    const refresh = signRefresh({ userId: user.id, role: user.role });
    res.cookie(COOKIE_NAME, refresh, COOKIE_OPTIONS);
    res.json({ access, user });
  } catch (err) {
    next(err);
  }
});

// POST /api/auth/google
// body: { idToken, role }
// Verify Google ID token using Google's tokeninfo endpoint
router.post('/google', async (req, res, next) => {
  try {
    const { idToken, role } = req.body;
    if (!idToken) return res.status(400).json({ error: 'Missing idToken' });

    // Verify token with Google
    const verifyUrl = `https://oauth2.googleapis.com/tokeninfo?id_token=${encodeURIComponent(idToken)}`;
    const resp = await fetch(verifyUrl);
    if (!resp.ok) {
      const txt = await resp.text();
      return res.status(400).json({ error: 'Google token verification failed', details: txt });
    }
    const payload = await resp.json();
    // payload contains: email, email_verified, name, picture, sub (Google user id)
    if (!payload.email) return res.status(400).json({ error: 'Google token missing email' });

    // Optionally check email_verified
    // if (payload.email_verified !== 'true' && payload.email_verified !== true) { ... }

    const user = await findOrCreateUser({
      name: payload.name,
      email: payload.email,
      phone: null,
      role: role || 'patient',
      auth_uid: payload.sub
    });

    // Optionally store auth_uid if not set
    await prisma.users.update({
      where: { id: user.id },
      data: { auth_uid: payload.sub }
    });

    const access = signAccess({ userId: user.id, role: role || user.role });
    const refresh = signRefresh({ userId: user.id, role: role || user.role });
    res.cookie(COOKIE_NAME, refresh, COOKIE_OPTIONS);
    res.json({ access, user });
  } catch (err) {
    next(err);
  }
});

// POST /api/auth/refresh
router.post('/refresh', async (req, res) => {
  try {
    const token = req.cookies[COOKIE_NAME];
    if (!token) return res.status(401).json({ error: 'No refresh token' });
    const payload = verifyRefresh(token);
    // Optionally, verify user still exists
    const user = await prisma.users.findUnique({ where: { id: payload.userId }});
    if (!user) return res.status(401).json({ error: 'Invalid token (user not found)' });

    const access = signAccess({ userId: user.id, role: user.role });
    res.json({ access, user });
  } catch (err) {
    return res.status(401).json({ error: 'Invalid refresh token' });
  }
});

// POST /api/auth/logout
router.post('/logout', (req, res) => {
  res.clearCookie(COOKIE_NAME, COOKIE_OPTIONS);
  res.json({ ok: true });
});

export default router;
